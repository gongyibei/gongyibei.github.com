{"meta":{"title":"Mariana是歌名啊","subtitle":null,"description":null,"author":"Mariana","url":"https://gongyibei.github.io"},"pages":[{"title":"分类","date":"2018-08-06T11:49:04.000Z","updated":"2018-08-06T11:50:03.045Z","comments":false,"path":"categories/index.html","permalink":"https://gongyibei.github.io/categories/index.html","excerpt":"","text":""},{"title":"日程表","date":"2018-08-06T23:29:51.000Z","updated":"2018-08-06T23:32:14.421Z","comments":false,"path":"schedule/index.html","permalink":"https://gongyibei.github.io/schedule/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-08-06T11:51:04.000Z","updated":"2018-08-06T11:51:58.317Z","comments":false,"path":"tags/index.html","permalink":"https://gongyibei.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生成器与协程","slug":"生成器与协程","date":"2018-08-06T19:32:53.000Z","updated":"2018-08-06T19:41:42.953Z","comments":true,"path":"2018/08/07/生成器与协程/","link":"","permalink":"https://gongyibei.github.io/2018/08/07/生成器与协程/","excerpt":"","text":"可用于迭代的类型 iterable 集合类 iterator generator 生成器 创建方法通过类似列表生成式的方式生成123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 调用含有yield语句的函数也可以得到12345678910def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt; 生成器对象的方法next()：从生成器中获取一个值。类似于send(None)send()：从生气器中获取一个值。并可以传入一个值作为yield语句的返回值 协程 创建方法使用`@asyncio.coroutine和yield from`123456import asyncio@asyncio.coroutinedef hello(): print(\"Hello world!\") r = yield from asyncio.sleep(1) print(\"Hello again!\") 3.5版本的新语法async和await1234async def hello(): print(\"Hello world!\") r = await asyncio.sleep(1) print(\"Hello again!\") yield from语句分析python不是通过`@asyncio.coroutine定义协程的，而是看定义的函数里有没有yield语句@asyncio.coroutine`的作用（《流畅的Python》18.1） 后面接可迭代对象，代替for123456def gen1(): for i in [1,2,3,4]: yield idef gen2(): yield from [1,2,3,4] async和await分析首先要理解其使用范围，要么在asyncio中使用，要么自己实现even loops。yield from 并没有完全被替代 async and await are specifically designed for asynchronous programming with event loopsasync await - Python native coroutines and send() - Stack Overflow 实例 通过yield实现的生产者-消费者模型123456789101112131415161718192021def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 调用generator时，通过return拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：123456789101112131415161718192021222324def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:... try:... x = next(g)... print('g:', x)... except StopIteration as e:... print('Generator return value:', e.value)... break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 参考 廖雪峰Python教程从0到1，Python异步编程的演进之路Python Async/Await入门指南","categories":[{"name":"python","slug":"python","permalink":"https://gongyibei.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gongyibei.github.io/tags/python/"},{"name":"异步","slug":"异步","permalink":"https://gongyibei.github.io/tags/异步/"}]},{"title":"最少通过几个音可以确定一个调？","slug":"最少通过几个音可以确定一个调","date":"2018-08-06T16:06:53.000Z","updated":"2018-08-06T22:40:04.409Z","comments":true,"path":"2018/08/07/最少通过几个音可以确定一个调/","link":"","permalink":"https://gongyibei.github.io/2018/08/07/最少通过几个音可以确定一个调/","excerpt":"","text":"注：本文的讨论仅限于自然调式 平时在练习扒谱的时候有注意到：当你在指板上找出相邻的两个音时，就可以把调的范围从12个缩小到2个。比如：当你找出2弦空弦与2弦1品是这个调的音时，这两个音要么是这个调的Mi-Fa，要么是这个调的Si-Do，当是Mi-Fa时这个调就是G调，当时Si-Do时就是C调。 可以猜想：不必找出这个调的所有音就可以确定这个调。那么最少找出几个音可以确定一个调呢？要找出哪几个音呢？ 自然大调中的12的调的组成音如下: 123456789101112C 调: C D E F G A BbD 调: bD bE F bG bA bB CD 调: D E bG G A B bDbE 调: bE F G bA bB C DE 调: E bG bA A B bD bEF 调: F G A bB C D EbG 调: bG bA bB B bD bE FG 调: G A B C D E bGbA 调: bA bB C bD bE F GA 调: A B bD D E bG bAbB 调: bB C D bE F G AB 调: B bD bE E bG bA bB 解答啊解答下面给出解答过程，😝没有兴趣的可以直接转到文末查看结论。 我们先把问题具体化，以C调为例。就是我们要从C调中找出几个音，然后这几个音在剩余11个调中都不同时存在，此问题可以抽象成如下的数学问题： 有N个非空集合。对于每一个集合，其中的每一个元素，在其他N-1个集合中至少存在一个集合包含这个元素。求每个集合的(不是其他N-1个集合中的任何一个集合的子集的)最小长度的子集 可以用无敌暴力穷举法对C调音名集合的全部子集进行验证(*￣︶￣)代码如下：12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-import pprintfrom itertools import combinationsDIATONIC_SCALE = ('C', 'bD', 'D', 'bE', 'E', 'F', 'bG', 'G', 'bA', 'A', 'bB','B')INTERVAL = (2, 2, 1, 2, 2, 2)def special(): \"\"\"special\"\"\" major_scales = [] for ind, main in enumerate(DIATONIC_SCALE): scale = DIATONIC_SCALE[ind:] + DIATONIC_SCALE[:ind] major_scale = [] major_scales.append(major_scale) i = 0 major_scale.append(scale[0]) for itv in INTERVAL: i += itv major_scale.append(scale[i]) for scale in major_scales: s = scale[0] main = [s + ' ', s][len(s) == 2] # print(main + ' 调: ' + ' '.join([s + ' ', s][len(s) == 2] for s in scale)) out = [] for i in range(7): for subset in combinations(major_scales[0], i): for superset in major_scales[1:]: subset = set(subset) if subset.issubset(set(superset)): break else: out.append(subset) out = [sorted(s,key = lambda i:DIATONIC_SCALE.index(i)) for s in out] return out if __name__ == '__main__': out = special() pprint.pprint(out) 输出的结果为：123456789101112131415161718192021222324252627282930[['C', 'F', 'B'], ['D', 'F', 'B'], ['E', 'F', 'B'], ['F', 'G', 'B'], ['F', 'A', 'B'], ['C', 'D', 'F', 'B'], ['C', 'E', 'F', 'B'], ['C', 'F', 'G', 'B'], ['C', 'F', 'A', 'B'], ['D', 'E', 'F', 'B'], ['D', 'F', 'G', 'B'], ['D', 'F', 'A', 'B'], ['E', 'F', 'G', 'B'], ['E', 'F', 'A', 'B'], ['F', 'G', 'A', 'B'], ['C', 'D', 'E', 'F', 'B'], ['C', 'D', 'F', 'G', 'B'], ['C', 'D', 'F', 'A', 'B'], ['C', 'E', 'F', 'G', 'B'], ['C', 'E', 'F', 'A', 'B'], ['C', 'F', 'G', 'A', 'B'], ['D', 'E', 'F', 'G', 'B'], ['D', 'E', 'F', 'A', 'B'], ['D', 'F', 'G', 'A', 'B'], ['E', 'F', 'G', 'A', 'B'], ['C', 'D', 'E', 'F', 'G', 'B'], ['C', 'D', 'E', 'F', 'A', 'B'], ['C', 'D', 'F', 'G', 'A', 'B'], ['C', 'E', 'F', 'G', 'A', 'B'], ['D', 'E', 'F', 'G', 'A', 'B']] 结果分析 输出结果中的每一行表示一种可能，也就是说我们最少需要找出3个音就可以确定一个调了。 仔细观察结果还可以发现，每一种可能中都含有F和B，找出F和B后至少再从剩下的5个音中随便找出1个就可了。也就是说假如你没有同时找出F和B，就算你找到了6个音也不能确定是什么调。这里有两个极端的例子。 当你找出F和B，其他11个调中同时含有这两个音的还有bG调，而且C调的另外5个音与bG调的另外5个音都不相同，所以再找一个音就可以确定是什么调了。 比如C调与G调就只有F和bG不一样，就算你找出了除F之外的6个音也不能确定是C调。 然后还有个规律就是F到B ，B到F都是相隔6个半音。1'C', 'bD', 'D', 'bE', 'E', 'F', 'bG', 'G', 'bA', 'A', 'bB','B' 结论：找出两个相差6个半音的音（即4级音和7级音），再至少找出一个音就可以确定调了更适合实践的方法是：在指板上找出两个相邻的音，看比这两个音中的较高把位的音高6个半音的音是不是这个调的音，如果是的话那么较高把位的这个音就是Fa，不是的话这个音就是Do（此时比这个音高5个半音的音会是这个调的音）。如此就可以确定调了 emmmmmmmm说了这么多，那么这个结论对实际找调有什么帮助呢。说实话一点luan用都没有，纯属没事找乐子：）","categories":[{"name":"吉他","slug":"吉他","permalink":"https://gongyibei.github.io/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"https://gongyibei.github.io/tags/吉他/"},{"name":"调式","slug":"调式","permalink":"https://gongyibei.github.io/tags/调式/"}]},{"title":"python的控制流程","slug":"python的控制流程","date":"2018-08-06T09:00:23.000Z","updated":"2018-08-06T10:36:03.834Z","comments":true,"path":"2018/08/06/python的控制流程/","link":"","permalink":"https://gongyibei.github.io/2018/08/06/python的控制流程/","excerpt":"","text":"for 循环 continuecontinue语句不是必须的12345678910111213for ： 语句一 if 条件： 语句二 continue 语句三# 转化后for ： 语句一 if 条件： 语句二 else： 语句三 有 continue或者break的if语句后的else 语句不是必要的。所以上例中没有加入else 12345678910111213141516for ： 语句一 if 条件： 语句二 continue else： 语句三 语句四# 转化后for ： 语句一 if 条件： 语句二 continue 语句三 语句四 else与breakelse是用于中断检测的，只有没有break时才执行。就是当你迭代的元素都满足条件时你希望做的事情。听起来有点奇怪，满足条件了然后执行else。为什么不是有break时，就执行else呢。假如是这样的话，你完全可以把语句四放到语句二的后面，这样就失去了else存在的意义，而且此时当没有break时要执行的语句就没法直接执行，你必须要加个变量作为判断的标志。 12345678for : 语句一 if 条件： 语句二 break 语句三else： 语句四 只有当有break时，才考虑用else。假如没有break，else就没有存在的意义了。因为无论如何else总会执行一次，完全可以把else里的语句放到整个for 语句之后","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://gongyibei.github.io/tags/python/"}]},{"title":"normal模式下快捷键","slug":"normal模式下快捷键","date":"2018-08-06T08:07:27.000Z","updated":"2018-08-06T10:32:58.840Z","comments":true,"path":"2018/08/06/normal模式下快捷键/","link":"","permalink":"https://gongyibei.github.io/2018/08/06/normal模式下快捷键/","excerpt":"","text":"移动 左右移动1234567891011&quot; 绝对移动0 -- 到行头^ -- 到本行的第一个非blank字符$ -- 到行尾g_ -- 到本行最后一个不是blank字符的位置f/F&#123;char&#125; -- 到下一个&#123;char&#125;字符的位置 t/T&#123;char&#125; -- 到下一个&#123;char&#125;字符前的位置&quot; 相对移动h -- 向左移动l -- 向右移动 上下移动12345678&quot; 绝对移动NG/Ngg -- 移到第N行gg -- 移到第一行G -- 移到最后一行&quot; 相对移动j -- 向下移动k -- 向上移动 其他移动1% -- 可对括号进行匹配移动 滚屏12345678910ctrl+f: 下翻一屏。ctrl+b: 上翻一屏。ctrl+d: 下翻半屏。ctrl+u: 上翻半屏。ctrl+e: 向下滚动一行。ctrl+y: 向上滚动一行。n%: 到文件n%的位置。zz: 将当前行移动到屏幕中央。zt: 将当前行移动到屏幕顶端。zb: 将当前行移动到屏幕底端。 编辑 插入删除123456d&#123;motion&#125; -- 删除移动过的范围 &#123;visual&#125;d -- 删除可视化的范围dd -- 删除一行D -- 删除到行尾x -- 删除一个字母X -- 往前删除一个字母 删除+插入123456c&#123;motion&#125; -- 删除移动过的范围并插入 &#123;visual&#125;c -- 删除可视化的范围并插入cc -- 删除一行并插入C -- 删除到行尾并插入s -- 删除一个字母并插入S -- 删除一行并插入 修改12r&#123;char&#125; -- 修改掉一个字母R -- 进入修改模式 区域选择区域选择的格式为：{action}N(i/a){object} 1234567891011121314151617&#123;action&#125; -- 可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)N -- 表示匹配object的次数i/a -- i表示不包括最外层边界，a表示包括最外层边界&#123;object&#125; -- 表示你选择的范围&#123;object&#125;有如下：w/W -- 一个单词s/S -- 一个句子p/P -- 一篇段落&apos; -- 单引号字符串&quot; -- 双引号字符串` -- 反向引用字符串b/(/) -- (块)B/&#123;/&#125;-- &#123;块&#125;[/] -- [块]&lt;/&gt; -- &lt;块&gt;t -- &lt;&gt;块&lt;&gt; 查找与替换 参考在 Vim 中优雅地查找和替换 | Harttle Land 查找12 更快捷的方式为123* -- 向下查找光标所在的单词# -- 向上查找光标所在的单词依旧可以用 n/N 选择下一个或上一个 替换替换的格式为：:{作用范围}s/{目标}/{替换}/{替换标志} 12345678910111213&quot; 作用范围默认是当前行visual模式选中的范围% -- 全局 2,11 -- 2到11行&quot; 目标与替换字符串，支持正则&quot; 替换标志g -- 全局i -- 不区分大小写 c -- 需要确|CTRL-E 其他 折叠1234567891011121314151617181920&quot; 基础zf -- 创建折叠的命令，可以在一个可视区域上使用该命令；za -- 打开/关闭当前折叠；zd -- 删除当前行的折叠；zi -- enable/disable fold;zj -- 跳到下一个折叠处；zk -- 跳到上一个折叠处；&quot; 全局折叠zr -- 打开嵌套的折行；zm -- 收起嵌套的折行；zR -- 打开所有折行；zM -- 收起所有折行；&quot; 所在行的折叠zo -- 打开折叠的文本；zc -- 收起折叠；zO -- 打开所有折行；zC -- 收起所有折行； 杂七杂八123ctrl+a -- 光标所在的数字+1ga -- 查看字符ascii码g8 -- 查看字符utf-8编码","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://gongyibei.github.io/tags/vim/"}]}]}