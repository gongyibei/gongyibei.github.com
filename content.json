{"meta":{"title":"Mariana是歌名啊","subtitle":null,"description":null,"author":"Mariana","url":"https://gongyibei.github.io"},"pages":[],"posts":[{"title":"logistic","slug":"logistic","date":"2019-04-25T15:19:26.000Z","updated":"2019-04-25T15:19:26.369Z","comments":true,"path":"2019/04/25/logistic/","link":"","permalink":"https://gongyibei.github.io/2019/04/25/logistic/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SVM","slug":"SVM","date":"2019-04-25T13:17:29.000Z","updated":"2019-04-25T13:20:08.109Z","comments":true,"path":"2019/04/25/SVM/","link":"","permalink":"https://gongyibei.github.io/2019/04/25/SVM/","excerpt":"","text":"线性回归 模型总览模型 $$h_\\theta(x)=\\theta^Tx$$ 优化目标 $$J(\\theta)=\\frac1m\\sum_{i-1}^{m}\\frac12(h_\\theta(x^{(i)})-y^{(i)})^2$$ 优化算法 梯度下降 正规方程 梯度下降$$\\theta_j:=\\theta_j-\\alpha\\frac{\\partial}{\\partial\\theta_j}J(\\theta)\\qquad(j=0,…,n)$$ 正规方程\b根据最小二乘法推倒出，可以直接从训练样本\b计算出$\\theta$，可证明计算出的$\\theta$是最优值: $$\\theta=(X^TX)^{-1}X^Ty$$ Octove中可如下求解 123pinv(X):伪逆inv(X):可逆pinv(X&apos;*X)*X&apos;*y \b一般来说$X^TX$是可逆的。如果不可逆，可能是由于包含了多余的特征\b 梯度下降与正规方程比较 梯度下降 正规方程 需要选择学习率 不需要 需要多次迭代 一次运算得出 当特征数量n大时也能较好适用$o(kn^2)$ 需要计算$(X^TX)^{-1}$如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为$o(n^3)$，通常来说当n小于10000 时还是可以接受的 适用于各种类型的模型 只适用于线性模型，不适合逻辑回归模型等其他模型 避免过拟合 删选特征\u001c 正则化 在代价函数\b中加入正则项，使参数$w$\b\b变小 特征缩放 feature scaling 章节5 课时30 \b归一化、标准化 代价函数推导 MAP 估计 ML 估计\b 最小\b二乘估计 与ML估计是等价的，\b推导过程不一样 正则最小二乘估计 $$J(\\theta)=\\frac1m\\sum_{i-1}^{m}\\frac12\\left[(h_\\theta(x^{(i)})-y^{(i)})^2+\\lambda\\sum_{j=1}^n\\theta_j^2\\right]$$ 其他形式\b增加x^2项，可以看做是增加了一个x^2的特征 损失函数 优化方法 线性回归 岭回归（L2正则化） Lasso回归（L1正则化） logistic 回归 模型总览模型 $$h_\\theta(x)=sigmoid(\\theta^TX)$$ 优化目标 优化算法 梯度下降 梯度下降感知器 \b模型总览：模型 优化目标 $$J(\\theta)=\\text{cost}(h_\\theta(x),y)=-y\\text{log}(h_\\theta(x))-(1-y)\\text{log}(1-h_\\theta(x))$$ $$J(\\theta)=\\frac1m\\sum_{i-1}^{m}\\left[-y\\text{log}(h_\\theta(x))-(1-y)\\text{log}(1-h_\\theta(x))\\right]$$ 1234567set terminal svgset title &quot;cost plots&quot; font &quot;,20&quot;set key left boxset samples 100set style data pointsplot [0:2] [0:4] -log(x),-log(1-x) 1234567set terminal svgset title &quot;cost plots&quot; font &quot;,20&quot;set key left boxset samples 100set style data pointsplot [0:1] (0.3**x)*(0.3**(1-x)) 优化算法 用梯度下降法，对$\\theta$进行更新 $$\\theta_j:=\\theta_j-\\alpha\\frac{\\partial}{\\partial\\theta_j}j(\\theta)$$ 求导后可得 $$\\theta_j:=\\theta_j-\\alpha\\sum_{i=1}^{m}(h_\\theta(x^{(i)}-y^{(i)})x_j^{(i)}$$ 优缺点## SVM 模型总览 区别 线性可分支持向量机 硬间隔最大化 线性支持向量机 软间隔最大化 非线性支持向量机 使用核函数 理解最大间隔函数间隔： $$\\hat\\gamma_i = y_i(w\\cdot x_i+b)=|w\\cdot x_i+b|$$ 最小函数间隔： $$\\hat\\gamma=\\min_{i=1,\\cdots,N}\\hat\\gamma_i$$ 几何间隔： $$\\gamma_i = y_i(\\frac{w}{|w|}\\cdot x_i+\\frac{b}{|w|})=|\\frac{w}{|w|}\\cdot x_i+\\frac{b}{|w|}|$$ 最小几何间隔： $$\\gamma=\\min_{i=1,\\cdots,N}\\gamma_i$$ 原问题线性可分下的原问题 $$\\min_{w,b}\\quad \\frac12|x|^2\\\\text{s.t.}\\quad y_i(w\\cdot x_i+b)-1\\ge0 $$ 线性不可分下的原问题： $$\\min_{w,b}\\quad \\frac12|x|^2+C\\sum_{i=1}^N\\xi_i\\\\text{s.t.}\\quad y_i(w\\cdot x_i+b)\\ge1-\\xi_i,\\quad i=1,2,\\cdots,N\\\\xi_i\\ge0,\\quad i=1,2,\\cdots,N $$ 对应的决策函数为： $$f(x)=\\text{sign}(w^\\cdot x+b^)= \\text{sign}(\\sum_{i=1}^{m}\\alpha_iy^{(i)}\\langle x^{(i)},x\\rangle+b)$$ 拉格朗日对偶弱对偶对所有的优化问题都成立，无论原问题是什么形式，对偶问题都是凸优化问题 用对偶问题求一个原问题的下界估计 强对偶 原始问题是凸优化问题的情况下，一般都满足强对偶 Slater条件 原问题为凸问题 首先要看我们的模型本身是否满足强对偶，Slater条件是满足强对偶的一种情况。 $$满足Slater条件\\quad\\to\\quad强对偶$$ KTT 而强对偶下的最优解一定是满足KTT条件的，所以我们可以通过KTT条件去筛选最优解， 而当原问题是凸问题的时候，满足KTT条件的点一定是最优解。 即弱对偶下KTT为必要条件，强对偶下KTT为充分条件 在强对偶下KTT为必要条件，如果原问题为凸问题，则变为充要条件 不清楚是否为凸优化： $$(x^,\\alpha^,\\beta^)是最优解\\quad\\to\\quad(x^,\\alpha^,\\beta^)满足KKT条件$$ 原问题为凸优化问题： $$(x^,\\alpha^,\\beta^)是最优解\\quad\\leftrightarrow\\quad(x^,\\alpha^,\\beta^)满足KKT条件$$ https://www.cnblogs.com/harvey888/p/7100815.htmlhttps://www.jianshu.com/p/96db9a1d16e9 http://blog.pluskid.org/?p=702 https://www.hrwhisper.me/ 对偶问题将原问题转换为对偶问题用到了拉格朗日对偶 线性可分的原问题可转化为对偶问题： $$\\min_\\alpha\\quad\\frac12\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum_{i=1}^{N}\\alpha_i \\ \\text{s.t.}\\quad\\sum_{i=1}^N\\alpha_iy_i=0\\\\alpha_i\\ge0\\ ,\\quad i=1,2,\\cdots,N $$ 线性不可分原问题可转化为对偶问题： $$\\min_\\alpha\\quad\\frac12\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum_{i=1}^{N}\\alpha_i \\\\text{s.t.}\\quad\\sum_{i=1}^N\\alpha_iy_i=0\\0\\le\\alpha_i\\le C\\ ,\\quad i=1,2,\\cdots,N$$ 核技巧定义$\\varphi(x)$为映射函数：把点$x$从原空间映射到新空间。通过$\\varphi(x)$把数据映射到高维： $$\\min_\\alpha\\quad\\frac12\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\alpha_i\\alpha_jy_iy_j(\\varphi(x_i)\\cdot\\varphi(x_j))-\\sum_{i=1}^{N}\\alpha_i \\\\text{s.t.}\\quad\\sum_{i=1}^N\\alpha_iy_i=0\\0\\le\\alpha_i\\le C\\ ,\\quad i=1,2,\\cdots,N$$ 定义函数$K(x_i,x_j)$： $$K(x_i,x_j)=\\varphi(x_i)\\cdot\\varphi(x_j)$$ 问题可转化为： $$\\min_\\alpha\\quad\\frac12\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\alpha_i\\alpha_jy_iy_jK(x_i,x_j)-\\sum_{i=1}^{N}\\alpha_i \\\\text{s.t.}\\quad\\sum_{i=1}^N\\alpha_iy_i=0\\0\\le\\alpha_i\\le C\\ ,\\quad i=1,2,\\cdots,N$$ 判别函数为: $$f(x)=\\text{sign}(w^\\cdot x+b^)= \\text{sign}(\\sum_{i=1}^{m}\\alpha_iy^{(i)}K(x^{(i)},x)+b)$$ 一个简单形式的核函数对应的$\\varphi(x)$就可能很复杂。因此只需要寻找一个合适的核函数$K(x_i,x_j)$，就可以把数据映射到足够高维。避免了直接去计算$\\varphi(x)$，大大减少了数据映射时的运算量。 常用的核函数有（$K(x,z)$表示核函数，$f(x)$表示对应的判别函数）： 多项式核函数： $K(x,z)=(x\\cdot z+1)^p$ $f(x)=\\text{sign}\\lgroup\\sum_{i=1}^{N_s}a_i^y_i(x_i\\cdot x+1)^p+b^\\rgroup$ 高斯核函数： $K(x,z)=\\exp(-\\frac{|x-z|^2}{2\\sigma^2})$ 字符串核函数： SMO算法其他形式 原问题 对偶问题 L1正则化L2-loss SVC 坐标下降法 - L2正则化L1-loss SVC （经典） - 坐标下降法 L2正则化L2-loss SVC 可信域牛顿法 坐标下降法 L1-loss SVR - 坐标下降法 L2-loss SVR 可信域牛顿法 坐标下降法 ## 并不一定要用拉格朗日对偶。 要注意用拉格朗日对偶并没有改变最优解，而是改变了算法复杂度：在原问题下，求解算法的复杂度与样本维度（等于权值w的维度）有关；而在对偶问题下，求解算法的复杂度与样本数量（等于拉格朗日算子a的数量）有关。 因此，如果你是做线性分类，且样本维度低于样本数量的话，在原问题下求解就好了，Liblinear之类的线性SVM默认都是这样做的；但如果你是做非线性分类，那就会涉及到升维（比如使用高斯核做核函数，其实是将样本升到无穷维），升维后的样本维度往往会远大于样本数量，此时显然在对偶问题下求解会更好。 作者：一氧化二氢货链接：https://www.zhihu.com/question/36694952/answer/69737932来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 线性分类器比较 激活函数 损失函数 优化方法 线性回归 - $(y-w^Tx)^2$ 最小二乘、梯度下降 Logistic回归 $\\sigma(w^Tx)$ $y\\log\\sigma(w^Tx)$ 梯度下降 Softmax回归 $\\text{softmax(}W^Tx)$ $y \\text{log softmax}(W^Tx)$ 梯度下降 感知器 $\\text{sgn}(w^Tx)$ $\\max(0,-yw^Tx)$ 随机梯度下降 支持向量机 $\\text{sgn}(w^Tx)$ $\\max(0,1-yw^Tx)$ 二次规划、SMO svm与lr（逻辑回归）的区别感知器、logistic与svm 区别与联系 - m0_37786651的博客 - CSDN博客MLP、RBF、SVM网络比较及其应用前景 - xiaoding133的专栏【Stay hungry,Stay foolish】 - CSDN博客标准化、归一化、正则化","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://gongyibei.github.io/tags/机器学习/"}]},{"title":"scheme基础","slug":"scheme基础","date":"2018-08-15T18:18:26.000Z","updated":"2018-08-15T18:47:40.915Z","comments":true,"path":"2018/08/16/scheme基础/","link":"","permalink":"https://gongyibei.github.io/2018/08/16/scheme基础/","excerpt":"","text":"基本结构 用户的lisp程序的结构就是一个巨大的S表达式有三种最基本的形式：特殊形式（special form）、函数调用形式 （function call form）和宏形式（macro form）。lisp解释器会对这个巨大的表达式进行计算得到一个值 特殊形式函数调用宏形式特殊形式（Special Form） 直接与编译器打交道，告诉编译器怎么做。 definelambdacons基础数据结构 Scheme中的简单数据类型包含 booleans (布尔类型) , number(数字类型), characters(字符类型) 和 symbols(标识符类型)。基础数据结构都是自解释的 booleans (布尔类型)number(数字类型)characters(字符类型)symbols(标识符类型)复合结构 String创建表示：”asdf as f” Vector创建：表示 点对 和 list（一定结构的嵌套的点对）其他数据类型 S表达式创建12(quote S)`S 操作1(eval `S) Common Lisp学习笔记（1）：语法和语义 | 优哉·幽斋 过程端口宏 如果用普通定义来定义则返回一个列表S 表达式，需要用eval对S表达式求值才能完成类似的功能","categories":[],"tags":[]},{"title":"生成器与协程","slug":"生成器与协程","date":"2018-08-06T19:32:53.000Z","updated":"2018-08-08T15:11:20.653Z","comments":true,"path":"2018/08/07/生成器与协程/","link":"","permalink":"https://gongyibei.github.io/2018/08/07/生成器与协程/","excerpt":"","text":"可用于迭代的类型 iterable 集合类 iterator generator 生成器创建方法通过类似列表生成式的方式生成123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 调用含有yield语句的函数也可以得到12345678910def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x104feaaa0&gt; 生成器对象的方法next()：从生成器中获取一个值。类似于send(None)send()：从生气器中获取一个值。并可以传入一个值作为yield语句的返回值 协程创建方法使用`@asyncio.coroutine和yield from`123456import asyncio@asyncio.coroutinedef hello(): print(\"Hello world!\") r = yield from asyncio.sleep(1) print(\"Hello again!\") 3.5版本的新语法async和await1234async def hello(): print(\"Hello world!\") r = await asyncio.sleep(1) print(\"Hello again!\") yield from语句分析python不是通过`@asyncio.coroutine定义协程的，而是看定义的函数里有没有yield语句@asyncio.coroutine`的作用（《流畅的Python》18.1） 后面接可迭代对象，代替for 123456def gen1(): for i in [1,2,3,4]: yield idef gen2(): yield from [1,2,3,4] async和await分析首先要理解其使用范围，要么在asyncio中使用，要么自己实现even loops。yield from 并没有完全被替代 async and await are specifically designed for asynchronous programming with event loopsasync await - Python native coroutines and send() - Stack Overflow 实例通过yield实现的生产者-消费者模型123456789101112131415161718192021def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 调用generator时，通过return拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中：123456789101112131415161718192021222324def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; g = fib(6)&gt;&gt;&gt; while True:... try:... x = next(g)... print('g:', x)... except StopIteration as e:... print('Generator return value:', e.value)... break...g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done 参考 廖雪峰Python教程从0到1，Python异步编程的演进之路Python Async/Await入门指南","categories":[{"name":"python","slug":"python","permalink":"https://gongyibei.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://gongyibei.github.io/tags/python/"},{"name":"异步","slug":"异步","permalink":"https://gongyibei.github.io/tags/异步/"}]},{"title":"最少通过几个音可以确定一个调？","slug":"最少通过几个音可以确定一个调","date":"2018-08-06T16:06:53.000Z","updated":"2018-08-15T18:47:48.853Z","comments":true,"path":"2018/08/07/最少通过几个音可以确定一个调/","link":"","permalink":"https://gongyibei.github.io/2018/08/07/最少通过几个音可以确定一个调/","excerpt":"","text":"注：本文的讨论仅限于自然调式 平时在练习扒谱的时候有注意到：当你在指板上找出相邻的两个音时，就可以把调的范围从12个缩小到2个。比如：当你找出2弦空弦与2弦1品是这个调的音时，这两个音要么是这个调的Mi-Fa，要么是这个调的Si-Do，当是Mi-Fa时这个调就是G调，当时Si-Do时就是C调。 可以猜想：不必找出这个调的所有音就可以确定这个调。那么最少找出几个音可以确定一个调呢？要找出哪几个音呢？ 自然大调中的12的调的组成音如下: 123456789101112C 调: C D E F G A BbD 调: bD bE F bG bA bB CD 调: D E bG G A B bDbE 调: bE F G bA bB C DE 调: E bG bA A B bD bEF 调: F G A bB C D EbG 调: bG bA bB B bD bE FG 调: G A B C D E bGbA 调: bA bB C bD bE F GA 调: A B bD D E bG bAbB 调: bB C D bE F G AB 调: B bD bE E bG bA bB 解答啊解答下面给出解答过程，😝没有兴趣的可以直接转到文末查看结论。 我们先把问题具体化，以C调为例。就是我们要从C调中找出几个音，然后这几个音在剩余11个调中都不同时存在，此问题可以抽象成如下的数学问题： 有N个非空集合。对于每一个集合，其中的每一个元素，在其他N-1个集合中至少存在一个集合包含这个元素。求每个集合的(不是其他N-1个集合中的任何一个集合的子集的)最小长度的子集 可以用无敌暴力穷举法对C调音名集合的全部子集进行验证(*￣︶￣)代码如下：12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-import pprintfrom itertools import combinationsDIATONIC_SCALE = ('C', 'bD', 'D', 'bE', 'E', 'F', 'bG', 'G', 'bA', 'A', 'bB','B')INTERVAL = (2, 2, 1, 2, 2, 2)def special(): \"\"\"special\"\"\" major_scales = [] for ind, main in enumerate(DIATONIC_SCALE): scale = DIATONIC_SCALE[ind:] + DIATONIC_SCALE[:ind] major_scale = [] major_scales.append(major_scale) i = 0 major_scale.append(scale[0]) for itv in INTERVAL: i += itv major_scale.append(scale[i]) for scale in major_scales: s = scale[0] main = [s + ' ', s][len(s) == 2] # print(main + ' 调: ' + ' '.join([s + ' ', s][len(s) == 2] for s in scale)) out = [] for i in range(7): for subset in combinations(major_scales[0], i): for superset in major_scales[1:]: subset = set(subset) if subset.issubset(set(superset)): break else: out.append(subset) out = [sorted(s,key = lambda i:DIATONIC_SCALE.index(i)) for s in out] return out if __name__ == '__main__': out = special() pprint.pprint(out) 输出的结果为：123456789101112131415161718192021222324252627282930[['C', 'F', 'B'], ['D', 'F', 'B'], ['E', 'F', 'B'], ['F', 'G', 'B'], ['F', 'A', 'B'], ['C', 'D', 'F', 'B'], ['C', 'E', 'F', 'B'], ['C', 'F', 'G', 'B'], ['C', 'F', 'A', 'B'], ['D', 'E', 'F', 'B'], ['D', 'F', 'G', 'B'], ['D', 'F', 'A', 'B'], ['E', 'F', 'G', 'B'], ['E', 'F', 'A', 'B'], ['F', 'G', 'A', 'B'], ['C', 'D', 'E', 'F', 'B'], ['C', 'D', 'F', 'G', 'B'], ['C', 'D', 'F', 'A', 'B'], ['C', 'E', 'F', 'G', 'B'], ['C', 'E', 'F', 'A', 'B'], ['C', 'F', 'G', 'A', 'B'], ['D', 'E', 'F', 'G', 'B'], ['D', 'E', 'F', 'A', 'B'], ['D', 'F', 'G', 'A', 'B'], ['E', 'F', 'G', 'A', 'B'], ['C', 'D', 'E', 'F', 'G', 'B'], ['C', 'D', 'E', 'F', 'A', 'B'], ['C', 'D', 'F', 'G', 'A', 'B'], ['C', 'E', 'F', 'G', 'A', 'B'], ['D', 'E', 'F', 'G', 'A', 'B']] 结果分析 输出结果中的每一行表示一种可能，也就是说我们最少需要找出3个音就可以确定一个调了。 仔细观察结果还可以发现，每一种可能中都含有F和B，找出F和B后至少再从剩下的5个音中随便找出1个就可了。也就是说假如你没有同时找出F和B，就算你找到了6个音也不能确定是什么调。这里有两个极端的例子。 当你找出F和B，其他11个调中同时含有这两个音的还有bG调，而且C调的另外5个音与bG调的另外5个音都不相同，所以再找一个音就可以确定是什么调了。 比如C调与G调就只有F和bG不一样，就算你找出了除F之外的6个音也不能确定是C调。 然后还有个规律就是F到B ，B到F都是相隔6个半音。1'C', 'bD', 'D', 'bE', 'E', 'F', 'bG', 'G', 'bA', 'A', 'bB','B' 结论：找出两个相差6个半音的音（即4级音和7级音），再至少找出一个音就可以确定调了更适合实践的方法是：在指板上找出两个相邻的音，看比这两个音中的较高把位的音高6个半音的音是不是这个调的音，如果是的话那么较高把位的这个音就是Fa，不是的话这个音就是Do（此时比这个音高5个半音的音会是这个调的音）。如此就可以确定调了 emmmmmmmm说了这么多，那么这个结论对实际找调有什么帮助呢。说实话一点luan用都没有，纯属没事找乐子：）","categories":[{"name":"吉他","slug":"吉他","permalink":"https://gongyibei.github.io/categories/吉他/"}],"tags":[{"name":"吉他","slug":"吉他","permalink":"https://gongyibei.github.io/tags/吉他/"},{"name":"调式","slug":"调式","permalink":"https://gongyibei.github.io/tags/调式/"}]},{"title":"python的控制流程","slug":"python的控制流程","date":"2018-08-06T09:00:23.000Z","updated":"2018-08-16T18:08:34.601Z","comments":true,"path":"2018/08/06/python的控制流程/","link":"","permalink":"https://gongyibei.github.io/2018/08/06/python的控制流程/","excerpt":"","text":"for 循环 continuecontinue语句不是必须的12345678910111213for ： 语句一 if 条件： 语句二 continue 语句三# 转化后for ： 语句一 if 条件： 语句二 else： 语句三 有 continue或者break的if语句后的else 语句不是必要的。所以上例中没有加入else 12345678910111213141516for ： 语句一 if 条件： 语句二 continue else： 语句三 语句四# 转化后for ： 语句一 if 条件： 语句二 continue 语句三 语句四 else与breakelse是用于中断检测的，只有没有break时才执行。就是当你迭代的元素都满足条件时你希望做的事情。听起来有点奇怪，满足条件了然后执行else。为什么不是有break时，就执行else呢。假如是这样的话，你完全可以把语句四放到语句二的后面，这样就失去了else存在的意义，而且此时当没有break时要执行的语句就没法直接执行，你必须要加个变量作为判断的标志。 12345678for : 语句一 if 条件： 语句二 break 语句三else： 语句四 只有当有break时，才考虑用else。假如没有break，else就没有存在的意义了。因为无论如何else总会执行一次，完全可以把else里的语句放到整个for 语句之后","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://gongyibei.github.io/tags/python/"}]},{"title":"normal模式下快捷键","slug":"normal模式下快捷键","date":"2018-08-06T08:07:27.000Z","updated":"2019-04-24T06:29:05.562Z","comments":true,"path":"2018/08/06/normal模式下快捷键/","link":"","permalink":"https://gongyibei.github.io/2018/08/06/normal模式下快捷键/","excerpt":"","text":"## 移动 左右移动1234567891011&quot; 绝对移动0 -- 到行头^ -- 到本行的第一个非blank字符$ -- 到行尾g_ -- 到本行最后一个不是blank字符的位置f/F&#123;char&#125; -- 到下一个&#123;char&#125;字符的位置 t/T&#123;char&#125; -- 到下一个&#123;char&#125;字符前的位置&quot; 相对移动h -- 向左移动l -- 向右移动 上下移动12345678&quot; 绝对移动NG/Ngg -- 移到第N行gg -- 移到第一行G -- 移到最后一行&quot; 相对移动j -- 向下移动k -- 向上移动 其他移动1% -- 可对括号进行匹配移动 滚屏12345678910ctrl+f: 下翻一屏。ctrl+b: 上翻一屏。ctrl+d: 下翻半屏。ctrl+u: 上翻半屏。ctrl+e: 向下滚动一行。ctrl+y: 向上滚动一行。n%: 到文件n%的位置。zz: 将当前行移动到屏幕中央。zt: 将当前行移动到屏幕顶端。zb: 将当前行移动到屏幕底端。 编辑 插入123456i -- 字母左边插入I -- 行首插入a -- 字母右边插入A -- 行尾插入o -- 下一行插入O -- 下一行插入 删除123456d&#123;motion&#125;:删除移动过的范围 &#123;visual&#125;d -- 删除可视化的范围dd -- 删除一行D -- 删除到行尾x -- 删除一个字母X -- 往前删除一个字母 删除+插入123456c&#123;motion&#125; -- 删除移动过的范围并插入 &#123;visual&#125;c -- 删除可视化的范围并插入cc -- 删除一行并插入C -- 删除到行尾并插入s -- 删除一个字母并插入S -- 删除一行并插入 修改12r&#123;char&#125; -- 修改掉一个字母R -- 进入修改模式 区域选择区域选择的格式为：{action}N(i/a){object} 1234567891011121314151617&#123;action&#125; -- 可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)N -- 表示匹配object的次数i/a -- i表示不包括最外层边界，a表示包括最外层边界&#123;object&#125; -- 表示你选择的范围&#123;object&#125;有如下：w/W -- 一个单词s/S -- 一个句子p/P -- 一篇段落&apos; -- 单引号字符串&quot; -- 双引号字符串` -- 反向引用字符串b/(/) -- (块)B/&#123;/&#125;-- &#123;块&#125;[/] -- [块]&lt;/&gt; -- &lt;块&gt;t -- &lt;&gt;块&lt;&gt; 查找与替换 参考在 Vim 中优雅地查找和替换 | Harttle Land 查找12 更快捷的方式为 123* -- 向下查找光标所在的单词# -- 向上查找光标所在的单词依旧可以用 n/N 选择下一个或上一个 替换替换的格式为：:{作用范围}s/{目标}/{替换}/{替换标志} 12345678910111213&quot; 作用范围默认是当前行visual模式选中的范围% -- 全局 2,11 -- 2到11行&quot; 目标与替换字符串，支持正则&quot; 替换标志g -- 全局i -- 不区分大小写 c -- 需要确|CTRL-E 其他 折叠1234567891011121314151617181920&quot; 基础zf -- 创建折叠的命令，可以在一个可视区域上使用该命令；za -- 打开/关闭当前折叠；zd -- 删除当前行的折叠；zi -- enable/disable fold;zj -- 跳到下一个折叠处；zk -- 跳到上一个折叠处；&quot; 全局折叠zr -- 打开嵌套的折行；zm -- 收起嵌套的折行；zR -- 打开所有折行；zM -- 收起所有折行；&quot; 所在行的折叠zo -- 打开折叠的文本；zc -- 收起折叠；zO -- 打开所有折行；zC -- 收起所有折行； 杂七杂八123ctrl+a -- 光标所在的数字+1ga -- 查看字符ascii码g8 -- 查看字符utf-8编码","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://gongyibei.github.io/tags/vim/"}]}]}